[{"title":"Hello world","url":"/2021/08/18/Hello-world/","content":"<p>又开始做起博客了，反反复复，总是坚持不下去，这次希望把这个网站做成分享日常和新知识的地方，希望这次能坚持下去吧。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["生活"]},{"title":"Mit:the missing semester 1","url":"/2023/05/16/Mit-the-missing-semester-1/","content":"<h1 id=\"这篇文章是干嘛的？\"><a href=\"#这篇文章是干嘛的？\" class=\"headerlink\" title=\"这篇文章是干嘛的？\"></a>这篇文章是干嘛的？</h1><p>这是用于记录我学习<a href=\"https://missing-semester-cn.github.io/\">MIT:The missing semester</a>课程的过程</p>\n<span id=\"more\"></span>\n\n<h1 id=\"什么是MIT-the-missing-semester\"><a href=\"#什么是MIT-the-missing-semester\" class=\"headerlink\" title=\"什么是MIT:the missing semester?\"></a>什么是MIT:the missing semester?</h1><p>这是一门由麻省理工大学的老师讲授的课程，教育学生们如何学习使用计算机专业常用工具。如Shell Vim Git 等一般课程不会讲授但是却对计算机学习十分有用的工具。</p>\n<h1 id=\"Shell常用指令\"><a href=\"#Shell常用指令\" class=\"headerlink\" title=\"Shell常用指令\"></a>Shell常用指令</h1><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd &lt;folder&gt; #打开folder文件夹</span><br><span class=\"line\">pwd #显示当前的工作目录</span><br><span class=\"line\">cd .. #打开上级目录</span><br><span class=\"line\">ls #显示当前目录下的所有文件</span><br><span class=\"line\">mv #重命名/移动文件</span><br><span class=\"line\">cp #拷贝文件</span><br><span class=\"line\">mkdir #新建文件夹</span><br><span class=\"line\">chmod #修改文件权限</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"程序间建立连接\"><a href=\"#程序间建立连接\" class=\"headerlink\" title=\"程序间建立连接\"></a>程序间建立连接</h1><p>在Shell中，程序有两个主要的流：输入流和输出流。</p>\n<p>程序读取信息时，会从输入流读取，打印信息时，会将信息输出到输出流中。</p>\n<p>通常输出流为终端，但可以重定向这些流，比如最简单的重定向 ‘&lt; file’ 和 ‘&gt; file’</p>\n<p>比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo hello &gt; hello.txt</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"built_in\">echo</span> hello 会输出hello，但由于输出流被重定向至hello.txt，所以终端无输出，hello.txt的内容变为hello</span></span><br><span class=\"line\">cat &lt; hello.txt &gt; hello2.txt</span><br><span class=\"line\">cat hello2.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">hello.txt被<span class=\"built_in\">cat</span>接收，<span class=\"built_in\">cat</span>的输出被hello2.txt接收，所以终端无输出，且hello2.txt变为hello</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以使用管道(pipes)更好的利用文件重定向。|操作符允许将程序的输出和另一个程序的输入连接起来</p>\n<p>比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps | grep process</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">ps获取当前所有的进程，并传给grep，grep查找名称带有process的进程，并输出到终端</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a>课后练习</h1><p>环境为：WSL2 Ubuntu 20.04</p>\n<ol>\n<li><p>cd &#x2F;tmp 打开’tmp’文件夹，mkdir missing 创建名称为 ‘missing’ 的文件夹</p>\n</li>\n<li><p>man touch 查看程序‘touch’的使用手册</p>\n</li>\n<li><p>touch semester 新建一个名为’semester’的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo &#x27;#!/bin/sh&#x27; &gt; semester</span><br><span class=\"line\">echo &#x27;curl --head --silent https://missing.csail.mit.edu&#x27; &gt;&gt; semester</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写入文件完成后 chmod +x semester 给予可执行权限</p>\n</li>\n<li><p>.&#x2F;semester 执行文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">WSL2指令：</span></span><br><span class=\"line\">cat /sys/class/power_supply/BAT1/capacity</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取到笔记本电量信息，大功告成</p>\n</li>\n</ol>\n","tags":["学习"]},{"title":"Mit:the missing semester 3","url":"/2023/07/03/Mit-the-missing-semester-3/","content":"<h1 id=\"课程目标\"><a href=\"#课程目标\" class=\"headerlink\" title=\"课程目标\"></a>课程目标</h1><p>学习Vim的设计原理以及基础知识，了解Vim的一部分高级功能</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Vim编辑模式\"><a href=\"#Vim编辑模式\" class=\"headerlink\" title=\"Vim编辑模式\"></a>Vim编辑模式</h1><p>Vim设计以大多数时间花在阅读、浏览和少量编辑为基础，因此具有多种操作模式：</p>\n<ol>\n<li>正常模式：在文件中四处移动光标进行修改 <kbd>Esc</kbd></li>\n<li>插入模式：插入文本 <kbd>I</kbd></li>\n<li>替换模式：替换文本 <kbd>R</kbd></li>\n<li>可视化模式：选中文本块 <kbd>V</kbd>行 <kbd>Ctrl-V</kbd>块</li>\n<li>命令模式：用于执行命令 <kbd>:</kbd></li>\n</ol>\n<p>不同模式下，键盘敲击的含义也不同，比如x在插入模式下会插入字母x，但在正常模式下会删除当前光标所在的字母，在可视化模式下会删除选中的块</p>\n<p>默认设置下，Vim会在左下角显示当前的模式，可以按下Esc键从任何其他模式返回正常模式</p>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><ul>\n<li><p>插入文本</p>\n<p>在正常模式按<kbd>i</kbd>进入插入模式，按下<kbd>Esc</kbd>返回正常模式</p>\n</li>\n<li><p>缓存、标签页、窗口</p>\n<p>Vim会维护打开的文件，称为“缓存”。一个Vim会话包含一系列标签页，每个标签页包含一系列窗口，每个窗口显示一个缓存，与网页浏览器不一样的是，缓存与窗口不是一一对应的，窗口只是视角，一个缓存可以在多个窗口打开，甚至在同一标签页的多个窗口打开。这个功能非常好用，比如在查看同一文件的不同部分的时候。</p>\n<p>Vim默认打开一个标签页，这个标签也包含一个窗口</p>\n</li>\n<li><p>命令行</p>\n<p>在正常模式键入 : 进入命令行模式，这个模式有很多功能，包括打开、保存、关闭文件以及退出Vim(新手噩梦)</p>\n<ul>\n<li><code>:q</code> 退出</li>\n<li><code>:w</code> 保存写</li>\n<li><code>:wq</code> 保存并退出</li>\n<li><code>:e &#123;文件名&#125;</code> 打开要编辑的文件</li>\n<li><code>:ls</code> 显示打开的缓存</li>\n<li><code>:help &#123;指令&#125;</code> 打开帮助文档</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Vim的接口\"><a href=\"#Vim的接口\" class=\"headerlink\" title=\"Vim的接口\"></a>Vim的接口</h1><p>Vim最重要的设计思想是Vim的界面本身是一个程序语言。</p>\n<ul>\n<li><p>移动</p>\n<p>多数情况会在正常模式下，使用移动命令在缓存中导航</p>\n<ul>\n<li>基本移动：<kbd>hjkl</kbd>（左，下，上，右）</li>\n<li>词： <kbd>w</kbd>（下一个词），<kbd>b</kbd>（词初），<kbd>e</kbd>（词尾）</li>\n<li>行： <kbd>0</kbd>（行初），<kbd>^</kbd>（第一个非空格字符），<kbd>$</kbd>（行尾）</li>\n<li>屏幕：<kbd>H</kbd>（屏幕首行），<kbd>M</kbd>（屏幕中间），<kbd>L</kbd>（屏幕底部）</li>\n<li>翻页：<kbd>Ctrl-u</kbd>（上翻），<kbd>Ctrl-d</kbd>（下翻）</li>\n<li>文件：<kbd>gg</kbd>（文件头部），<kbd>G</kbd>（文件尾部）</li>\n<li>行数：<code>:&#123;行数&#125;</code>   <code>&#123;行数&#125;G</code></li>\n<li>杂项：<kbd>%</kbd>（找到配对，比如括号或者&#x2F;**&#x2F;之类的注释对） </li>\n<li>查找： <code>f&#123;字符&#125;</code>，<code>t&#123;字符&#125;</code>，<code>F&#123;字符&#125;</code>，<code>T&#123;字符&#125;</code> 查找&#x2F;到 向前&#x2F;向后 在本行的字符。 <kbd>,</kbd>&#x2F;<kbd>;</kbd>用于导航匹配</li>\n<li>搜索：<code>/&#123;正则表达式&#125;</code>，<kbd>n</kbd>&#x2F;<kbd>N</kbd>用于导航匹配</li>\n</ul>\n</li>\n<li><p>编辑</p>\n<p>抛弃鼠标，所有需要用鼠标做的事，现在都可以用键盘，采用编辑命令和移动命令的组合来完成。</p>\n<ul>\n<li><p><kbd>i</kbd> 进入插入模式</p>\n</li>\n<li><p><kbd>O</kbd>&#x2F;<kbd>o</kbd> 在上方&#x2F;下方插入行</p>\n</li>\n<li><p><code>d&#123;移动命令&#125;</code> 删除{移动命令}</p>\n<p>例如<code>dw</code>删除词，<code>d$</code>删除到行尾，<code>d0</code>删除到行头</p>\n</li>\n<li><p><code>c&#123;移动命令&#125;</code> 改变{移动命令}</p>\n<p>例如，<code>cw</code>改变词</p>\n</li>\n<li><p><code>x</code> 删除字符（等同于<code>dl</code>）</p>\n</li>\n<li><p><code>s</code> 替换字符（等同于<code>xi</code>）</p>\n</li>\n<li><p>可视化模式+操作 选中文字，<code>d</code>删除，<code>c</code>改变</p>\n</li>\n<li><p><code>u</code> 撤销 <code>C-r</code>重做</p>\n</li>\n<li><p><code>y</code> 复制</p>\n</li>\n<li><p><code>p</code> 粘贴</p>\n</li>\n</ul>\n</li>\n<li><p>重复</p>\n<p>可以用一个技术结合指令，这会执行指定的指令若干次，例如：</p>\n<ul>\n<li><code>3w</code> 向前移动三个词</li>\n<li><code>5j</code> 向下移动5行</li>\n<li><code>7dw</code> 删除7个词</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"自定义Vim\"><a href=\"#自定义Vim\" class=\"headerlink\" title=\"自定义Vim\"></a>自定义Vim</h1><p>Vim有一个位于<code>~/.vimrc</code>的文本配置文件。</p>\n<p>可以更换为课程推荐的设置，修复了一些Vim默认设置的奇怪行为，<a href=\"https://missing-semester-cn.github.io/2020/files/vimrc\">下载地址</a>，保存为<code>~/.vimrc</code></p>\n<h1 id=\"Vim扩展\"><a href=\"#Vim扩展\" class=\"headerlink\" title=\"Vim扩展\"></a>Vim扩展</h1><p>Vim有许多的扩展插件，从Vim8.0开始即内置了一个插件管理器，只需要创建一个<code>~/.vim/pack/vendor/start/</code>的文件夹，将插件放到此处即可使用。</p>\n<p>以下为课程推荐的几个插件：</p>\n<ul>\n<li><a href=\"https://github.com/ctrlpvim/ctrlp.vim\">ctrlp.vim</a> 模糊文件查找</li>\n<li><a href=\"https://github.com/mileszs/ack.vim\">ack.vim</a> 代码搜索</li>\n<li><a href=\"https://github.com/preservim/nerdtree\">nerdtree</a> 文件浏览器</li>\n<li><a href=\"https://github.com/easymotion/vim-easymotion\">vim-easymotion</a> 魔术操作</li>\n</ul>\n<h1 id=\"Vim进阶\"><a href=\"#Vim进阶\" class=\"headerlink\" title=\"Vim进阶\"></a>Vim进阶</h1><p>不想学，略。</p>\n","tags":["学习"]},{"title":"Mit:the missing semester 2","url":"/2023/05/16/Mit-the-missing-semester-2/","content":"<h1 id=\"课程目标\"><a href=\"#课程目标\" class=\"headerlink\" title=\"课程目标\"></a>课程目标</h1><p>学习Bash作为脚本语言的一些基础操作，以及几种最常用的shell工具</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h1><p>大多数Shell都有自己的一套脚本语言，包括变量、控制流和语法。本次主要学习Bash脚本，因为它最流行，应用最广泛</p>\n<ol>\n<li><p>赋值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo=bar</span><br><span class=\"line\"><span class=\"comment\">#将bar的值赋给foo</span></span><br><span class=\"line\">foo = bar</span><br><span class=\"line\"><span class=\"comment\">#不能正确工作，会调用程序foo并将=和bar作为参数传入程序</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar=1</span><br><span class=\"line\">foo=bar</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$foo</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#输出1</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;$foo&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#输出$foo</span></span><br><span class=\"line\"><span class=\"comment\">#Bash中字符串通过&#x27;和&quot;分隔符定义，&#x27;定义的字符串为原义，&quot;定义的字符串将会替换为变量值</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#bash也支持if、case、while和for这些控制流关键词</span></span><br><span class=\"line\"><span class=\"comment\">#例如mcd()&#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">mkdir</span> -p <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">cd</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#其中$1为特殊变量，Bash中有许多特殊变量，例如：</span></span><br><span class=\"line\"><span class=\"comment\"># $0 脚本名</span></span><br><span class=\"line\"><span class=\"comment\"># $1 -&gt; $9 脚本的第n个参数</span></span><br><span class=\"line\"><span class=\"comment\"># $@ 所有参数</span></span><br><span class=\"line\"><span class=\"comment\"># $# 参数个数</span></span><br><span class=\"line\"><span class=\"comment\">#更多特殊变量可到官方文档查看：https://www.tldp.org/LDP/abs/html/special-chars.html</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回码</p>\n<p>Bash指令通常使用stdout返回输入值，stderr返回错误和错误码，返回值为0表示正常运行，返回其他任何非零的值都表示发生错误，与C&#x2F;C++类似。</p>\n<p>退出码可以搭配&amp;&amp;和||使用，更好地实现运行结果的处理</p>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span> || <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Oops,fail&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#将会输出Oops,fail</span></span><br><span class=\"line\"><span class=\"literal\">true</span> || <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Will not printed&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#将不会有输出</span></span><br><span class=\"line\"><span class=\"literal\">false</span> &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">&quot;will not printed&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#将不会有输出</span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Things went well&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#将会输出Things went well</span></span><br><span class=\"line\"><span class=\"comment\">#因为||和&amp;&amp;都属于短路运算符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#还可以用;分隔同一行的多个命令，例如</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> l ; <span class=\"built_in\">cd</span> l</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令替换</p>\n<p>可以在命令中使用$(command)来执行所需的命令，命令中$(command)将会被command的输出所替换，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Now time is <span class=\"subst\">$(date)</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#$(date)将被替换为date的输出结果，即当前的日期和时间</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通配</p>\n<p>通配符：可以分别使用 ? 和 * 来匹配一个或任意个字符。</p>\n<p>例如对于文件 foo,foo1,foo2,fool0和bar</p>\n<p>rm foo? 会删除 foo1 和 foo2</p>\n<p>rm foo* 会删除除bar以外的所有文件</p>\n<br>\n\n<p>花括号：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">convert &quot;img.&#123;png,jpg&#125;&quot;</span><br><span class=\"line\">#等价于 convert &quot;img.png img.jpg&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">mv *.&#123;py,sh&#125; folder</span><br><span class=\"line\">#可以和通配符结合使用，将所有的.py .sh文件移动到folder文件夹中</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>补充</p>\n<p>编写Bash脚本有时候会非常别扭和反直觉，可以使用<a href=\"https://github.com/koalaman/shellcheck\">shellcheck</a>这种工具定位脚本中的错误</p>\n<p>脚本不一定只有用Bash写的才能在终端中调用，例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/local/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">for</span> arg <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(sys.argv[<span class=\"number\">1</span>:])</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(arg)</span><br></pre></td></tr></table></figure>\n\n<p>内核知道使用python解释器来执行而不是shell，因为第一行的shebang</p>\n<p>还可以在shebang行中使用env命令，会利用环境变量中的程序来解析该脚本，可以提高脚本的可移植性，env会利用PATH环境变量来进行定位，例如：<code>#!/usr/bin/env python</code>。</p>\n</li>\n</ol>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><ol>\n<li><p>查看命令如何使用</p>\n<p>课程中推荐使用man命令和<a href=\"https://tldr.sh/\">TLDR pages</a>，但我不习惯使用这些工具，我推荐善用搜索引擎<a href=\"https://www.google.com/\">Google</a> <a href=\"https://www.bing.com/\">Bing</a> <a href=\"https://www.baidu.com/\">Baidu</a></p>\n</li>\n<li><p>所有类UNIX系统都会包含一个名为<code>find</code>的工具，是在shell中查找文件最方便的工具，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查找所有名称为src的文件夹</span></span><br><span class=\"line\">find . -name src -<span class=\"built_in\">type</span> d</span><br><span class=\"line\"><span class=\"comment\">#查找所有文件夹路径包含test的python文件</span></span><br><span class=\"line\">find . -path <span class=\"string\">&#x27;*/test/*.py&#x27;</span> -<span class=\"built_in\">type</span> f</span><br><span class=\"line\"><span class=\"comment\">#查找所有前一天修改的文件</span></span><br><span class=\"line\">find . -mtime -1</span><br><span class=\"line\"><span class=\"comment\">#查找所有大小在500K到1M的tar.gz文件</span></span><br><span class=\"line\">find . -size +500k -size -1M -name <span class=\"string\">&#x27;*.tar.gz&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#删除所有扩展名为.tmp的文件</span></span><br><span class=\"line\">find . -name <span class=\"string\">&#x27;*.tmg&#x27;</span> -<span class=\"built_in\">exec</span> <span class=\"built_in\">rm</span> &#123;&#125; \\;</span><br><span class=\"line\"><span class=\"comment\">#查找所有png文件并转化为jpg</span></span><br><span class=\"line\">find . -name <span class=\"string\">&#x27;*.png&#x27;</span> -<span class=\"built_in\">exec</span> convert &#123;&#125; &#123;&#125;.jpg \\;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a>课后练习</h1><ol>\n<li><p>使用<code>ls</code>进行以下操作</p>\n<ol>\n<li><p>打印所有文件（包括隐藏文件）</p>\n<p><code>ls -a</code></p>\n</li>\n<li><p>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是454279954)</p>\n<p><code>ls -l -h</code></p>\n</li>\n<li><p>文件以最近访问顺序排序</p>\n<p><code>ls -t</code></p>\n</li>\n<li><p>以彩色文本显示输出结果</p>\n<p><code>ls --color=auto</code></p>\n</li>\n</ol>\n</li>\n<li><p>编写两个bash函数  marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行  polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便debug，你可以把代码写在单独的文件  marco.sh 中，并通过 source marco.sh命令，（重新）加载函数。通过source 来加载函数，随后可以在 bash  中直接使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">marco</span></span>()&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"subst\">$(pwd)</span>&quot;</span> &gt; /marco.log</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">polo</span></span>()&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cd</span> <span class=\"string\">&quot;<span class=\"subst\">$(cat <span class=\"string\">&quot;/marco.log&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"built_in\">echo</span> &gt; out.log</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t./bugshell.sh &amp;&gt;&gt; out.log</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> [[$? -ne 0]] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cat</span> out.log</span><br><span class=\"line\">\t\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Failed after <span class=\"variable\">$count</span> attempts&quot;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">break</span></span><br><span class=\"line\">\t<span class=\"keyword\">fi</span></span><br><span class=\"line\">\t((count++))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本节课我们讲解的 find 命令中的 -exec 参数非常强大，它可以对我们查找的文件进行操作。 如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如tar 则需要从参数接受输入。这里我们可以使用<a href=\"https://man7.org/linux/man-pages/man1/xargs.1.html\">xargs</a> 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm  会删除当前目录中的所有文件。您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 xargs的参数-d）</p>\n<p><code>find . -name &quot;*.html&quot; | xargs -d &#39;\\n&#39; tar -czvf html.zip</code></p>\n</li>\n</ol>\n","tags":["学习"]},{"title":"Mit:the missing semester 4","url":"/2023/08/07/Mit-the-missing-semester-4/","content":"<h1 id=\"数据整理\"><a href=\"#数据整理\" class=\"headerlink\" title=\"数据整理\"></a>数据整理</h1><p>跳过</p>\n","tags":["学习"]},{"title":"Mit:the missing semester 6","url":"/2023/08/08/Mit-the-missing-semester-6/","content":"<h1 id=\"版本控制（Git）\"><a href=\"#版本控制（Git）\" class=\"headerlink\" title=\"版本控制（Git）\"></a>版本控制（Git）</h1><p>建议改用 <a href=\"https://learngitbranching.js.org/?locale=zh_CN\">Git小游戏</a> 学习</p>\n","tags":["学习"]},{"title":"Winodws11平台下的VScode C/C++环境配置","url":"/2021/11/16/Winodws11%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84VScode-C-C-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"<ol>\n<li><p>前往<a href=\"https://code.visualstudio.com/\" title=\"VSCode官网\">VSCode官网</a>下载并安装VSCode</p>\n<span id=\"more\"></span>\n</li>\n<li><p>在<a href=\"https://nuwen.net/mingw.html\" title=\"Mingw镜像站\">Mingw镜像站</a>下载并安装Mingw，安装目录为 “C:&quot; 如图所示</p>\n<p> <img src=\"https://i.imgur.com/ApyXF0D.png\"></p>\n<p><img src=\"https://i.imgur.com/gdqUlnO.png\"></p>\n</li>\n<li><p>添加系统环境变量PATH的值为 “C:\\MinGW\\bin” 图为另一种配置方法<br><img src=\"https://i.imgur.com/x8NocFj.png\"></p>\n<p><img src=\"https://i.imgur.com/czzWCVh.png\"></p>\n</li>\n<li><p>安装VSCode插件  </p>\n</li>\n<li><p>开始愉快的编程之旅！</p>\n</li>\n</ol>\n","tags":["学习"]},{"title":"Mit:the missing semester 5","url":"/2023/08/07/Mit-the-missing-semester-5/","content":"<h1 id=\"课程目标\"><a href=\"#课程目标\" class=\"headerlink\" title=\"课程目标\"></a>课程目标</h1><p>学习如何同时执行多个不同进程并追踪他们的状态，如何停止或暂停某个进程以及如何使进程在后台中运行。学习改善shell及其他工具的工作流的方法。学习如何使用SSH操作远端机器。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"任务控制\"><a href=\"#任务控制\" class=\"headerlink\" title=\"任务控制\"></a>任务控制</h1><p>某些情况我们需要中断正在执行的任务，比如当一个任务需要执行很长时间时，我们可以使用<kbd>Ctrl-C</kbd>来停止命令的执行。</p>\n<ul>\n<li><p>结束进程</p>\n<p>shell会使用UNIX提供的信号机制执行进程间通信。当一个进程接收到信号时，就会停止执行，处理该信号并基于该信号传递的信息来改变其执行，即信号是一种软件中断</p>\n<p>如上面的例子，当我们输入<kbd>Ctrl-C</kbd>时，shell会发送一个<code>SiGINT</code>信号到进程。但程序可以忽略它，例如下面这段程序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> signal,time</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">handler</span>(<span class=\"params\">signum,time</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nI got a SIGINT,but I am not stopping&quot;</span>)</span><br><span class=\"line\">signal.signal(signal.SIGINT,handler)</span><br><span class=\"line\">i=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\r&#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(i),end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>如果向这段程序发送<code>SIGINT</code>，程序并不会结束，只有向程序发生<code>SIGQUIT</code><kbd>Ctrl-\\</kbd>，程序才会退出</p>\n<p>尽管<code>SIGINT</code>和<code>SIGQUIT</code>都常用于发送终止程序相关的请求，<code>SIGTERM</code>是跟家通用、也更加优雅的退出信号。为了发送这个信号，我们需要使用<code>kill</code>命令，<code>kill -TERM &lt;PID&gt;</code></p>\n</li>\n<li><p>暂停和后台执行进程</p>\n<p>信号可以让进程做其他的事情，而不仅仅是终止他们。例如<code>SIGSTOP</code>会让进程暂停，在终端中，<kbd>Ctrl-Z</kbd>会让shell发送<code>SIGTSTP</code>信号(<code>SIGSTOP</code>不能被忽略，<code>SIGTSTP</code>可以被忽略)，可以使用<code>fg</code>或<code>bg</code>命令恢复暂停的工作，分别表示在前台继续或在后台继续。</p>\n<p><code>jobs</code>命令会列出当前终端会话中尚未完成的全部任务，可以使用pid引用这些任务(可以用<code>pgrep</code>找出pid)，也可以使用百分号+任务编号选取任务。如果要选择最近的一个任务，可以使用特殊参数<code>$!</code>。</p>\n<p>Tips：命令中的<code>&amp;</code>后缀可以让命令直接在后台运行，可以直接在shell中进行其他操作，但是进程此时还是会使用shell的标准输出（可以使用shell重定向处理解决）</p>\n<p>键入<kbd>Ctrl-Z</kbd>可以让运行的进程转到后台运行，输入<code>bg</code>让进程在后台继续。但此时后台的进程仍然是终端进程的子进程，一旦关闭终端（会发送信号<code>SIGHUP</code>），后台的进程也将终止，为了防止此情况发生，可以在命令前加<code>nohup </code>（用于忽略<code>SIGHUIP</code>的封装）来运行程序。</p>\n<p><code>SIGKILL</code>是一个特殊的信号，不能被进程捕获，并且它会马上结束该进程，不过会有些副作用，例如留下孤儿进程（父进程退出，但子进程还在运行）</p>\n</li>\n</ul>\n<h1 id=\"终端多路复用\"><a href=\"#终端多路复用\" class=\"headerlink\" title=\"终端多路复用\"></a>终端多路复用</h1><p>在使用命令行时，通常会希望同时执行多个任务，此时可以使用终端多路复用器。</p>\n<p>像tmux,screen这类终端多路复用器可以允许我们基于面板和标签分割多个终端窗口，可以同时与多个shell会话进行交互。并且可以分离当前终端会话并在将来重新连接，大大改变了操作远端设备的工作流，避免了<code>nohup</code>和其他类似技巧的使用。</p>\n<p>tmux是现在最流行的终端多路器。可以使用相关快捷键创建多个标签页并在它们间导航。tmux的快捷键都是类似<code>&lt;C-b&gt; x</code>这样的组合，需要先按下<kbd>Ctrl-B</kbd>，松开后按下<kbd>X</kbd></p>\n<ul>\n<li>会话：每个会话都是独立的工作区，包含一个或多个窗口<ul>\n<li><code>tmux</code> 开启一个新的会话</li>\n<li><code>tmux new -s Name</code> 以指定名称开启一个新的会话</li>\n<li><code>tmux ls</code> 列出当前所有会话</li>\n<li><code>tmux a</code> 重新连接最后一个会话</li>\n</ul>\n</li>\n<li>窗口：相当于浏览器中的标签页，将会话分割为多个部分<ul>\n<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口</li>\n<li><code>&lt;C-b&gt; N</code> 跳转到第N个窗口</li>\n<li><code>&lt;C-b&gt; p</code> 跳转到前一个窗口</li>\n<li><code>&lt;C-b&gt; n</code> 跳转到下一个窗口</li>\n<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>\n<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>\n</ul>\n</li>\n<li>面板：像Vim中的分屏一样，可以在一个屏幕显示多个shell<ul>\n<li><code>&lt;C-b&gt; &quot;</code> 水平分割为两个面板</li>\n<li><code>&lt;C-b&gt; %</code> 垂直分割为两个面板</li>\n<li><code>&lt;C-b&gt; 方向</code> 切换到指定方向的面板（方向指键盘的方向键）</li>\n<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>\n<li><code>&lt;C-b&gt; 空格</code> 在不同的面板排布间切换</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h1><p>输入一长串指令非常麻烦，大部分shell都支持设置别名，相当于一个长命令的缩写，shell会自动将其替换为原本的命令。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> alias_name=<span class=\"string\">&quot;command_to_alias arg1 arg2&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意<code>=</code>两边没有空格，因为<code>alias</code>是一个shell命令，只接受一个参数。</p>\n<p>alias常用特性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建常用命令的缩写</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> ll=<span class=\"string\">&quot;ls -lh&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 能够少输入很多</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> gs=<span class=\"string\">&quot;git status&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> gc=<span class=\"string\">&quot;git commit&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> v=<span class=\"string\">&quot;vim&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 手误打错命令也没关系</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> sl=<span class=\"built_in\">ls</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新定义一些命令行的默认行为</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> <span class=\"built_in\">mv</span>=<span class=\"string\">&quot;mv -i&quot;</span>           <span class=\"comment\"># -i prompts before overwrite</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> <span class=\"built_in\">mkdir</span>=<span class=\"string\">&quot;mkdir -p&quot;</span>     <span class=\"comment\"># -p make parent dirs as needed</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> <span class=\"built_in\">df</span>=<span class=\"string\">&quot;df -h&quot;</span>           <span class=\"comment\"># -h prints human readable format</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 别名可以组合使用</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> la=<span class=\"string\">&quot;ls -A&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> lla=<span class=\"string\">&quot;la -l&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在忽略某个别名</span></span><br><span class=\"line\">\\<span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 或者禁用别名</span></span><br><span class=\"line\"><span class=\"built_in\">unalias</span> la</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取别名的定义</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> ll</span><br><span class=\"line\"><span class=\"comment\"># 会打印 ll=&#x27;ls -lh&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>PS：默认情况下，shell并不会保存别名，为了让别名持续生效，需要将配置放进shell的启动文件里，例如<code>.bashrc</code>或<code>.zshrc</code></p>\n<h1 id=\"远端设备\"><a href=\"#远端设备\" class=\"headerlink\" title=\"远端设备\"></a>远端设备</h1><p>教程详细说明的SSH的各种高级用法，但我认为部分用法用处不大，且有更方便的方法，故此处只写SSH的基本操作。</p>\n<ul>\n<li><p>连接：</p>\n<p>通过如下命令，可以使用ssh连接到其他服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh foo@bar.mit.edu</span><br><span class=\"line\"><span class=\"comment\">#尝试以用户名foo 登录服务器bar.mit.edu</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SSH密钥</p>\n<p>只需要向服务器证明客户端持有对应的私钥，无需公开私钥，可以避免每次都输入密码。私钥（通常是<code>~/.ssh/id_rsa</code>或者<code>~/.ssh/id_ed25519</code>）等效于密码，好好保管。</p>\n</li>\n<li><p>密钥生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -o -a100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure></li>\n</ul>\n","tags":["学习"]},{"title":"JavaEE Learning Note - MVC","url":"/2023/08/23/JavaEE-Learning-Note-MVC/","content":"<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><p>JSP文件的内容其实是一个HTML，必须放在<code>/src/main/webapp</code>下，文件名以<code>.jsp</code>结尾，在需要动态输出的地方，使用特殊指令<code>&lt;% ... %&gt;</code>。</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%-- 注释 --%&gt;</span><br><span class=\"line\">&lt;% java代码 %&gt;\t&lt;%-- 可以编写任意java代码 --%&gt;</span><br><span class=\"line\">&lt;%=  xxx   %&gt;\t &lt;%-- 可以快捷输出一个变量的值 --%&gt;</span><br></pre></td></tr></table></figure>\n\n<p>JSP页面内置了几个变量：</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>out：表示<code>HttpServletResponse</code>的<code>PrintWriter</code></li>\n<li>session：表示当前<code>HttpSession</code>对象</li>\n<li>request：表示<code>HttpServletRequest</code>对象</li>\n</ol>\n<p>JSP本质上就是一个Servlet，只是无需配置映射路径。在服务器运行过程中，如果修改了JSP的内容，服务器会自动重新编译。</p>\n<h1 id=\"MVC开发\"><a href=\"#MVC开发\" class=\"headerlink\" title=\"MVC开发\"></a>MVC开发</h1><p>MVC开发就是将Servlet和JSP相结合，Servlet负责处理数据，JSP负责展示页面。</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> School school;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">School</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 假装从数据库读取:</span></span><br><span class=\"line\">        <span class=\"type\">School</span> <span class=\"variable\">school</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">School</span>(<span class=\"string\">&quot;No.1 Middle School&quot;</span>, <span class=\"string\">&quot;101 South Street&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"number\">123</span>, <span class=\"string\">&quot;Bob&quot;</span>, school);</span><br><span class=\"line\">        <span class=\"comment\">// 放入Request中:</span></span><br><span class=\"line\">        req.setAttribute(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">        <span class=\"comment\">// forward给user.jsp:</span></span><br><span class=\"line\">        req.getRequestDispatcher(<span class=\"string\">&quot;/WEB-INF/user.jsp&quot;</span>).forward(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%@ page <span class=\"keyword\">import</span>=<span class=\"string\">&quot;com.itranswarp.learnjava.bean.*&quot;</span>%&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> (User) request.getAttribute(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Hello World - JSP&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello &lt;%= user.name %&gt;!&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;School Name:</span><br><span class=\"line\">    &lt;span style=<span class=\"string\">&quot;color:red&quot;</span>&gt;</span><br><span class=\"line\">        &lt;%= user.school.name %&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;School Address:</span><br><span class=\"line\">    &lt;span style=<span class=\"string\">&quot;color:red&quot;</span>&gt;</span><br><span class=\"line\">        &lt;%= user.school.address %&gt;</span><br><span class=\"line\">    &lt;/span&gt;</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：</p>\n<ol>\n<li>要把<code>user.jsp</code>放到<code>/WEB-INF/</code>目录下，阻止用户通过<code>/user.jsp</code>绕过Servlet直接访问JSP页面。</li>\n<li>JSP直接从<code>request</code>获取<code>User</code>实例，然后直接输出，此处未考虑html的转义，有潜在安全风险。</li>\n</ol>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>我们把<code>UserServlet</code>看作业务逻辑处理，把<code>User</code>看作模型，把<code>user.jsp</code>看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即<code>UserServlet</code>作为控制器（Controller），<code>User</code>作为模型（Model），<code>user.jsp</code>作为视图（View）</p>\n<p>使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。</p>\n<h2 id=\"MVC的设计\"><a href=\"#MVC的设计\" class=\"headerlink\" title=\"MVC的设计\"></a>MVC的设计</h2><p>MVC框架有一个接收所有请求的<code>Servlet</code>，通常我们把它命名为<code>DispatcherServlet</code>，映射到<code>/</code>，然后根据不同Controller方法定义的<code>@Get</code>或<code>@Post</code>的Path决定调用哪个方法，最后获得方法返回的<code>ModeAndView</code>渲染模板，写入<code>HttpServletResponse</code>。</p>\n<p>其中，<code>DispatcherServlet</code>以及如何渲染均由MVC框架实现，在MVC框架之上只需要编写每一个Controller。</p>\n","tags":["学习"]},{"title":"JavaEE Learning Note - Servlet","url":"/2023/08/17/JavaEE-Learning-Note-Servlet/","content":"<h1 id=\"Servlet入门\"><a href=\"#Servlet入门\" class=\"headerlink\" title=\"Servlet入门\"></a>Servlet入门</h1><p>使用教程为<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">廖雪峰老师的Java教程</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"最简单的Servlet实现：\"><a href=\"#最简单的Servlet实现：\" class=\"headerlink\" title=\"最简单的Servlet实现：\"></a>最简单的Servlet实现：</h2><ul>\n<li><p>将Servlet API导入Maven</p>\n<p>编辑<code>pox.xml</code>，添加打包类型，设置为<code>war</code>，表示为Java Web Application Archive</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>war<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入项目依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>jakarta.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jakarta.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>6.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span>     <span class=\"comment\">&lt;!--版本号可修改为最新的--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--打包为war文件需要的插件--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-war-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意<code>&lt;scope&gt;</code>指定为<code>provided</code>，表示编译时使用，不会打包进<code>war</code>文件中，因为运行期Web服务器本身已经提供了Servlet API相关的jar包。</p>\n<p>基本代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> jakarta.servlet.http.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class=\"line\">            <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置响应类型:</span></span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取输出流:</span></span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">pw</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        <span class=\"comment\">// 写入响应:</span></span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// flush强制输出:</span></span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>项目工程结构为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JavaEELearn</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │      └── HelloServlet.java</span><br><span class=\"line\">        ├── resources   ##存放网站的资源文件</span><br><span class=\"line\">        └── webapp</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载Tomcat并安装</p>\n<ul>\n<li>使用Servlet&lt;&#x3D;4.0时，使用Tomcat 9.x</li>\n<li>使用Servlet&gt;&#x3D;5.0时，使用Tomcat 10.x</li>\n</ul>\n</li>\n<li><p>项目构建运行</p>\n<p>使用<code>mvn clean package</code>生成war文件，将war文件重命名为<code>Root.war</code>，放入<code>%Tomcat%/webapps</code>中，运行<code>%Tomcat%/bin/startup.bat</code>或者<code>%Tomcat%/bin/startup.sh</code>启动Tomcat服务器，默认监听端口为8080，访问<code>http://localhost:8080/</code>即可。</p>\n</li>\n</ul>\n<h1 id=\"Servlet进阶\"><a href=\"#Servlet进阶\" class=\"headerlink\" title=\"Servlet进阶\"></a>Servlet进阶</h1><p>一个Web App就是由一个或多个Servlet组成的，每个Servlet通过注解设置自己处理的路径。</p>\n<p>浏览器发送请求时，有多种不同类型的请求，比如GET，POST，PUT。为了处理这些不同的请求，我们需要覆写这些请求的方法，例如<code>doGet()</code> <code>doPost()</code>。</p>\n<h2 id=\"HttpServletRequest\"><a href=\"#HttpServletRequest\" class=\"headerlink\" title=\"HttpServletRequest\"></a>HttpServletRequest</h2><p><code>HttpServletRequest</code>封装了一个Http请求，实际上时从<code>ServletRequest</code>继承的，可以通过<code>HttpServletRequest</code>提供的接口方法获得Http请求的几乎全部信息，常用的方法有：</p>\n<ul>\n<li>getMethod()        获取请求方法，例如<code>GET</code> <code>POST</code></li>\n<li>getRequestURI()        获取请求路径，但不包括请求的参数，例如<code>&quot;/index&quot;</code></li>\n<li>getQuerryString()        获取请求参数，例如<code>&quot;name=123&amp;age=11&amp;sex=1&quot;</code></li>\n<li>getParameter(name)        获取指定的参数，GET从URL读取，POST从Body中读取</li>\n<li>getContentType()        获取请求Body的类型，例如<code>&quot;application/x-www-form-urlencoded&quot;</code></li>\n<li>getContextPath()        获取当前Webapp挂载的路径</li>\n<li>getCookies()        获取请求携带的所有Cookie</li>\n<li>getHeader(name)        获取指定的Header</li>\n<li>getHeaderNames()        获取所有的Header</li>\n<li>getInputStream()        打开一个输入流读取Body</li>\n<li>getReader()        打开一个Reader读取Body</li>\n<li>getRemoteAddr()        获取客户端的IP</li>\n<li>getScheme()        获取协议类型，例如<code>http</code> <code>https</code></li>\n</ul>\n<h2 id=\"HttpServletResponse\"><a href=\"#HttpServletResponse\" class=\"headerlink\" title=\"HttpServletResponse\"></a>HttpServletResponse</h2><p><code>HttpServletResponse</code>封装了一个Http响应，由于Http响应必须先发送Header，再发送Body，所以操作<code>HttpServletResponse</code>对象时，必须先调用设置Header的方法，最后调用发送Body的方法</p>\n<p>常用设置Header的方法有：</p>\n<ul>\n<li>setStatus(sc)        设置响应代码，默认为200</li>\n<li>setContentType(type)        设置Body的类型，例如<code>&quot;text/html&quot;</code></li>\n<li>setCharacterEncoding(charset)        设置字符编码，例如<code>&quot;UTF-8&quot;</code></li>\n<li>setHeader(name,value)        设置一个Header的值</li>\n<li>addCookie(cookie)        给响应添加一个Cookie</li>\n<li>addHeader(name,value)        添加一个Header，因为Http协议允许多个相同的Header</li>\n</ul>\n<p>写入响应时，需要通过<code>getOutputStream()</code>获取写入流，或者通过<code>getWriter()</code>获取字符流，二者只能获取其中的一个。</p>\n<p>写入响应前，无需<code>setContentLength()</code>，底层服务器会自动设置好。</p>\n<p>写入完毕后，必须调用<code>flush()</code>刷新缓冲区，将缓冲区的内容发送到客户端，并且，禁止调用<code>close()</code>，因为这样会关闭TCP连接，使Web服务器无法复用此连接</p>\n<h2 id=\"Servlet多线程模型\"><a href=\"#Servlet多线程模型\" class=\"headerlink\" title=\"Servlet多线程模型\"></a>Servlet多线程模型</h2><p>一个Servlet类在服务器中只有一个实例，但对于每个Http请求，服务器会使用多线程执行请求，因此，一个Servlet的处理请求的方法是多线程并发执行的，要注意多线程并发访问的问题。</p>\n<p>对于每个请求，Web服务器会创建唯一的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例，他们总是局部变量，不存在多线程共享的问题。</p>\n<h2 id=\"重定向与转发\"><a href=\"#重定向与转发\" class=\"headerlink\" title=\"重定向与转发\"></a>重定向与转发</h2><h3 id=\"Redirect\"><a href=\"#Redirect\" class=\"headerlink\" title=\"Redirect\"></a>Redirect</h3><p>重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns=&quot;/hi&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedirectServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        String name=req.getParameter(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">redirectToUrl</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/hello&quot;</span>+(name==<span class=\"literal\">null</span> ? <span class=\"string\">&quot;&quot;</span>:<span class=\"string\">&quot;?name&quot;</span>+name);</span><br><span class=\"line\">        resp.sendRedirect(redirectToUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若浏览器发送<code>Get /hi</code>请求，会收到服务器的302回应，要求访问新路径。产生两次Http请求，浏览器地址栏自动更新为重定向后的地址。</p>\n<p>302响应为临时重定向，301响应为永久重定向</p>\n<p>永久重定向写法为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class=\"comment\">// 301</span></span><br><span class=\"line\">resp.setHeader(<span class=\"string\">&quot;Location&quot;</span>, <span class=\"string\">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Forward\"><a href=\"#Forward\" class=\"headerlink\" title=\"Forward\"></a>Forward</h3><p>Forward是指内部转发，当一个Servlet处理请求时，它可以决定自己不继续处理，而是转发给另一个Servlet处理，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/morning&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ForwardServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        req.getRequestDispatcher(<span class=\"string\">&quot;/hello&quot;</span>).forward(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ForwardServlet</code>在收到请求后，它并不自己发送请求，而是把请求和响应都转发给路径为<code>/hello</code>的Servlet，后续的请求实际上是由<code>HelloServlet</code>完成的。</p>\n<p>转发与重定向的区别在于，转发是在Web服务器内部完成的，对于浏览器来说，他只是发出了一个Http请求，浏览器并不知道该请求在Web服务器内实际做了一次转发。</p>\n<h2 id=\"Session和Cookie\"><a href=\"#Session和Cookie\" class=\"headerlink\" title=\"Session和Cookie\"></a>Session和Cookie</h2><p>Http协议是一个无状态协议，Web服务器无法区分收到的两个请求是否是同一个浏览器发出的，为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，以Cookie的形式发送到浏览器，浏览器在后续访问中总是附带此Cookie，这样，服务器就可以识别出来用户的身份。</p>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><p>我们把这种基于唯一ID识别用户身份的机制称为Session，每个用户第一次访问服务器后，会自动后将获得一个Session ID。若用户一段时间未访问服务器，Session会自动失效，即使下次访问带着上次分配的Session ID访问，服务器也会认作新用户，分配一个新的Session ID。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/signin&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SignInServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟一个数据库:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, String&gt; users = Map.of(<span class=\"string\">&quot;bob&quot;</span>, <span class=\"string\">&quot;bob123&quot;</span>, <span class=\"string\">&quot;alice&quot;</span>, <span class=\"string\">&quot;alice123&quot;</span>, <span class=\"string\">&quot;tom&quot;</span>, <span class=\"string\">&quot;tomcat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GET请求时显示登录页:</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">pw</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Sign In&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;form action=\\&quot;/signin\\&quot; method=\\&quot;post\\&quot;&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;p&gt;Username: &lt;input name=\\&quot;username\\&quot;&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;p&gt;Password: &lt;input name=\\&quot;password\\&quot; type=\\&quot;password\\&quot;&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;p&gt;&lt;button type=\\&quot;submit\\&quot;&gt;Sign In&lt;/button&gt; &lt;a href=\\&quot;/\\&quot;&gt;Cancel&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// POST请求时处理用户登录:</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> req.getParameter(<span class=\"string\">&quot;username&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> req.getParameter(<span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">expectedPassword</span> <span class=\"operator\">=</span> users.get(name.toLowerCase());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expectedPassword != <span class=\"literal\">null</span> &amp;&amp; expectedPassword.equals(password)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 登录成功:</span></span><br><span class=\"line\">            req.getSession().setAttribute(<span class=\"string\">&quot;user&quot;</span>, name);</span><br><span class=\"line\">            resp.sendRedirect(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            resp.sendError(HttpServletResponse.SC_FORBIDDEN);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其他页面获取用户名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IndexServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从HttpSession获取当前用户名:</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> (String) req.getSession().getAttribute(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        resp.setCharacterEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        resp.setHeader(<span class=\"string\">&quot;X-Powered-By&quot;</span>, <span class=\"string\">&quot;JavaEE Servlet&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">pw</span> <span class=\"operator\">=</span> resp.getWriter();</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Welcome, &quot;</span> + (user != <span class=\"literal\">null</span> ? user : <span class=\"string\">&quot;Guest&quot;</span>) + <span class=\"string\">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 未登录，显示登录链接:</span></span><br><span class=\"line\">            pw.write(<span class=\"string\">&quot;&lt;p&gt;&lt;a href=\\&quot;/signin\\&quot;&gt;Sign In&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 已登录，显示登出链接:</span></span><br><span class=\"line\">            pw.write(<span class=\"string\">&quot;&lt;p&gt;&lt;a href=\\&quot;/signout\\&quot;&gt;Sign Out&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除Session：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/signout&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SignOutServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从HttpSession移除用户名:</span></span><br><span class=\"line\">        req.getSession().removeAttribute(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">        resp.sendRedirect(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Web服务器来说，我们通过<code>HttpSession</code>接口访问当前Session，可以理解为Web服务器在内存中自动维护了一个ID到HttpSession的映射表。</p>\n<p>服务器识别Session的关键就是依靠一个名为JSESSIONID的Cookie。在第一次调用<code>req.getSession()</code>时，服务器自动创建一个SessionID，然后通过名为JSESSIONID的Cookie发送给浏览器。</p>\n<p>使用Session时，由于服务器把所有用户的Session都存储在内存中，如果遇到内存不足的情况，就需要把部分不活动的Session序列化到磁盘上，这会大大降低服务器的运行效率，因此，放入Session的对象要小，通常我们放入一个简单的<code>User</code>对象就足够了。</p>\n<p>在使用多台服务器构成集群时，使用Session会遇到一些额外的问题。Session适用于中小型Web应用程序，对于大型应用程序来说，通常需要避免使用Session机制.</p>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>Servlet提供的<code>HttpSession</code>本质上是通过一个名为<code>JSESSIONID</code>的Cookie来跟踪用户对话，除这个名称外，其他名称的Cookie我们可以任意使用。</p>\n<p>比如可以编写一个<code>LanguageServlet</code>设置Cookie记录用户选择的语言。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet(urlPatterns = &quot;/pref&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LanguageServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;String&gt; LANGUAGES = Set.of(<span class=\"string\">&quot;en&quot;</span>, <span class=\"string\">&quot;zh&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">lang</span> <span class=\"operator\">=</span> req.getParameter(<span class=\"string\">&quot;lang&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LANGUAGES.contains(lang)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建一个新的Cookie:</span></span><br><span class=\"line\">            <span class=\"type\">Cookie</span> <span class=\"variable\">cookie</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cookie</span>(<span class=\"string\">&quot;lang&quot;</span>, lang);</span><br><span class=\"line\">            <span class=\"comment\">// 该Cookie生效的路径范围:</span></span><br><span class=\"line\">            cookie.setPath(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 该Cookie有效期:</span></span><br><span class=\"line\">            cookie.setMaxAge(<span class=\"number\">8640000</span>); <span class=\"comment\">// 8640000秒=100天</span></span><br><span class=\"line\">            <span class=\"comment\">// 将该Cookie添加到响应:</span></span><br><span class=\"line\">            resp.addCookie(cookie);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resp.sendRedirect(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建Cookie时，除了指定名称和值以外，通常还要设置<code>setPath(&quot;&lt;Path&gt;&quot;)</code>，浏览器根据此前缀决定是否发送Cookie，如果网页是Https，还需要调用setSecure(true)，否则浏览器不会发送该Cookie。</p>\n<p>Cookie的读取主要靠遍历<code>HttpServletRequest</code>实现，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">parseLanguageFromCookie</span><span class=\"params\">(HttpServletRequest req)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取请求附带的所有Cookie:</span></span><br><span class=\"line\">    Cookie[] cookies = req.getCookies();</span><br><span class=\"line\">    <span class=\"comment\">// 如果获取到Cookie:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cookies != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环每个Cookie:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Cookie cookie : cookies) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果Cookie名称为lang:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cookie.getName().equals(<span class=\"string\">&quot;lang&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 返回Cookie的值:</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> cookie.getValue();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回默认值:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;en&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["学习"]}]